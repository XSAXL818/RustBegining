# 所有权

- 是Rust最独特的特性，它能让Rust无需GC（垃圾回收机制）就可以保证内存安全。
  - GC:程序运行时，会自动寻找不再使用的内存，然后释放。
  - 其他语言，需要程序员显式地分配和释放内存。
- Rust采用第三种方式：
  - 内存通过所有权系统来管理，其中包含一组编译器在编译时检查的规则。
  - 当程序运行时，所有权特性不会减慢程序的运行速度。



## 1、栈内存和堆内存

- 在Rust中，一个值在stack和在heap堆程序来说有很大的影响。
- 代码运行时，stack和heap都是可用的内存，但结构不相同。



### 存储数据的区别

- stack即先进后出。
- 所有存在在stack上的数据必须拥有已知的固定大小。
- heap内存组织性较差。通常操作：申请一定数量的空间，操作系统在heap中找到，然后返回该空间的首地址，该过程通常称为分配。
- 数据压到stack上比在heap上分配快得多。



### 访问数据的区别

- 访问heap中的数据要比访问stack的数据满，因为需要通过指针。
- 数据存放的距离较近时，stack速度更快。



### 函数调用

- 代码调用函数时，值被传入到函数。函数本地的变量被压到stack上。函数结束后，值被弹出。



### 所有权存在的原因

- 所有权要解决的问题：
  - 跟踪代码的哪些部分正在使用heap的哪些数据
  - 最小化heap上的重复数据量
  - 清理heap上未使用的数据以避免空间不足
- 一旦使用所有权，不需要经常关注stack和heap
- 管理heap数据是所有权存在的原因



## 2、所有权的规则、内存和分配

### 所有权规则

- 每个值都有一个变量，这个变量是该值的所有者。

- 每个值同时只能有一个所有者

- 当所有者超出作用域时，值被删除（emmm，目前只看字面的话，这个域在C++使用{}就可以实现？），作用域（scope）就是程序中一个项目的有效范围。

  即变量只在{}内是可用的，{}外不可以访问{}内的元素

  ```rust
  let mut a = 3;
  {
      a = 5;// 可行，{}外的变量，在{}内可以访问
      let mut b = 4;
  }
  b = 4;// 不可行
  ```



### String类型

- 字符串字面量：即程序中手写的那些字符串值。它们是不可变的。
- Rust的第二种字符串类型：String。在heap上分配，能够存储在编译时未知数量的文本。

#### 创建String类型的值

- 可以是用from函数从字符串字面值创建出String类型

- let s = String::from(“hello”);

- 该字符串可以被改变。

- &str类型，切片字符串，即所有字符串字面量都是唯一存在的，如"world"和"hello"，只存在一份。&str类型的变量包含起始和结束地址，以此指向固定长度的字符串字面量。

  ```rust
  let mut ss = "hello";
  println!("{:p}",ss);// 
  ss = "world1";
  println!("{:p}",ss);// 地址变了，即指向"world"了
  ss = "hello";
  println!("{:p}",ss);// 变回最大时的地址
  
  
  
  let mut s = String::from("hello");
  println!("{:p}",&s);
  s.push_str(", xsaxl");
  println!("{:p}",&s);
  ```

  

#### 内存和分配

- 字符串字面值，在编译时就知道其内容，可直接硬编码到最终的可执行文件中。因此速度快、高效。
- 





